package com.bumpslide.util {        import flash.display.DisplayObject;   	import flash.geom.Rectangle;   	    /**	* Alignment utilities	* 	* When designing resizable apps, it is often the case that movie clips need 	* to be programmatically aligned and/or centered.  The static methods in this	* class take care of the math involved in many of these cases.  When used on their	* own, they are handy.  When used in conjunction with StageProxy, they are stellar.	* 	* StageProxy is a singleton that proxies Stage.onResize events and can be used to 	* maintain min and max stage dimensions.  By default, the stageProxy's height and 	* width properties are used as the default value for the containerSize in these 	* methods.	* 	* The methods also assume that the 0,0 registration point on the to-be-aligned 	* clip is in the top-left corner.  If this is not the case, you can compensate	* by adjusting the clipSize, or just do the calculation by hand.	* 	* @author David Knape	*/		public class Align	{				/**		* Right-aligns a clip		* 		* Example Usage: 		*   Align.right( mymenu_mc );		* 		* @param	clip		* @param	containerSize		* @param	clipSize		*/		static public function right(clip:DisplayObject, containerSize:Number, clipSize:Number=Number.NaN) : void 		{ 							var rect:Rectangle = clip.getRect(clip);					if(isNaN(clipSize)) clipSize = rect.width;						clip.x = Math.round( containerSize - clipSize - rect.x);				}					/**		* Centers a clip horizontally		* 		* Example Usage: 		*   Align.center( mymenu_mc );		* 		* @param	clip		* @param	containerSize		* @param	clipSize		*/		static public function center( clip:DisplayObject, containerSize:Number, clipSize:Number=Number.NaN ) : void 		{				var rect:Rectangle = clip.getRect(clip);			if(isNaN(clipSize)) clipSize = rect.width;								clip.x = Math.round( (containerSize - clipSize - rect.x) / 2);		}						/**		* Centers a clip vertically 		* 		* Example Usage: 		*   Align.middle( mymenu_mc );		* 		* @param	clip		* @param	containerSize		* @param	clipSize		*/		static public function middle( clip:DisplayObject, containerSize:Number, clipSize:Number=Number.NaN ) : void 		{				var rect:Rectangle = clip.getRect(clip);			if(isNaN(clipSize)) clipSize = rect.height;								clip.y = Math.round( (containerSize - clipSize - rect.y) / 2);		}				/**		* Aligns a clip with the bottom of a container		* 		* Example Usage: 		*   Align.bottom( mymenu_mc );		* 		* @param	clip		* @param	containerSize		* @param	clipSize		*/		static public function bottom( clip:DisplayObject, containerSize:Number, clipSize:Number=Number.NaN ) : void 		{				var rect:Rectangle = clip.getRect(clip);			if(isNaN(clipSize)) clipSize = rect.height;								clip.y = Math.round( (containerSize - clipSize - rect.y) );		}			//		/**//		* Stacks movie clips as if they are in a VBox //		* //		* DisplayObject height is pulled from a setter (height) if found. //		* Otherwise, positions are calulated based on getBounds results.//		* //		* @param	clips//		* @param	padding//		*///		static public function vbox( clips:Array, padding:Number ) : void {//			if(padding==null) padding = 0;//			var count:int = clips.length;//			if(count<2) return;		//				//			// calculate starting position//			var yPos:Number;//			var mc:DisplayObject = clips[0];	//			if(mc.height!=null) {//				yPos = mc.y + mc.height + padding;//			} else {//				yPos = mc.getBounds( mc.parent ).yMax + padding;//			}//			//trace('[vbox] starting y position = ' + yPos );//			for(var n=1; n<count; ++n) {//				mc = clips[n];//				if(mc.visible==false) continue;//							//				// use 'height' getter if found//				if(mc.height!=null) {//					//					// using 'height', and assuming top at y=0 (no bounds checking)//					mc.y = Math.round( yPos );//					yPos += mc.height + padding;//					//				} else {//					//					// using getBounds to determing height and y position//					mc.y = Math.round( yPos + mc.y - mc.getBounds( mc.parent ).yMin );	//					yPos = mc.getBounds( mc.parent ).yMax + padding;//					//				}//				//trace('[vbox] (clip '+n+') '+mc._name+'.y = ' + mc.y );	//				//trace('[vbox] y position = ' + yPos );//			}		//		}//		//		/**//		* arranges movie clips in a row as if they are in a HBox //		* //		* @param	clips//		* @param	padding//		*///		static public function hbox( clips:Array, padding:Number ) : void {//			if(padding==null) padding = 0;//			var count:int = clips.length;//			if(count<2) return;		//			var xPos:Number = clips[0].getBounds( clips[0]._parent ).xMax + padding;	//			for(var n=1; n<count; ++n) {//				var mc:DisplayObject = clips[n];//				if(mc.visible==false) continue;//				mc.x = Math.round( xPos + mc.x - mc.getBounds( mc.parent ).xMin);		//				xPos = mc.getBounds( mc.parent ).xMax + padding;//			}		//		}				}}